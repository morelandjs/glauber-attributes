#!/usr/bin/env python3

import argparse
from collections import defaultdict
import glob
import logging

import matplotlib.pyplot as plt
from matplotlib import lines
from matplotlib import patches
from matplotlib import ticker
import numpy as np


fontsmall, fontnormal, fontlarge = 5, 6, 7
offblack = '#262626'
aspect = 1/1.618
resolution = 72.27
textwidth = 307.28987/resolution
textheight = 261.39864/resolution
fullwidth = 350/resolution
fullheight = 270/resolution

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'serif',
    'font.serif': ['CMU Serif'],
    'font.size': fontnormal,
    'legend.fontsize': fontnormal,
    'axes.labelsize': fontnormal,
    'axes.titlesize': fontlarge,
    'xtick.labelsize': fontsmall,
    'ytick.labelsize': fontsmall,
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'lines.linewidth': .5,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .5,
    'axes.linewidth': .4,
    'xtick.major.width': .4,
    'ytick.major.width': .4,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 1.2,
    'ytick.major.size': 1.2,
    'xtick.minor.size': .8,
    'ytick.minor.size': .8,
    'xtick.major.pad': 1.5,
    'ytick.major.pad': 1.5,
    'axes.formatter.limits': (-5, 5),
    'axes.spines.top': False,
    'axes.spines.right': False,
    'axes.labelpad': 3,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.cmap': 'Blues',
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})


plot_functions = {}


def plot(f):
    """
    Plot function decorator.  Calls the function, does several generic tasks,
    and saves the figure as the function name.

    """
    def wrapper(*args, **kwargs):
        logging.info('generating plot: %s', f.__name__)
        f(*args, **kwargs)

        fig = plt.gcf()

        if not fig.get_tight_layout():
            set_tight(fig)

        plotfile = '{}.png'.format(f.__name__)
        fig.savefig(str(plotfile), dpi=400)
        logging.info('wrote %s', plotfile)
        plt.close(fig)

    plot_functions[f.__name__] = wrapper

    return wrapper


def set_tight(fig=None, **kwargs):
    """
    Set tight_layout with a better default pad.

    """
    if fig is None:
        fig = plt.gcf()

    kwargs.setdefault('pad', .1)
    fig.set_tight_layout(kwargs)


def auto_ticks(ax, axis='both', minor=False, **kwargs):
    """
    Convenient interface to matplotlib.ticker locators.

    """
    axis_list = []

    if axis in {'x', 'both'}:
        axis_list.append(ax.xaxis)
    if axis in {'y', 'both'}:
        axis_list.append(ax.yaxis)

    for axis in axis_list:
        axis.get_major_locator().set_params(**kwargs)
        if minor:
            axis.set_minor_locator(ticker.AutoMinorLocator(minor))


@plot
def uncertainties(nbin=50):
    """
    Calculate <Ncoll>(Centrality) for each set of trento arguments

    """
    fig, axes = plt.subplots(
        nrows=2, ncols=2,
        figsize=(textwidth, aspect*textwidth),
        sharex=True
    )

    plot_attrs = [('Npart', 2), ('Ncoll', 3)]
    blue, red = [plt.cm.Blues(.6), plt.cm.Reds(.6)]

    # alice glauber model
    alice_glauber = {}
    for attr, _ in plot_attrs:
        fname = 'alice/{}.dat'.format(attr)
        x, y, yerr = np.loadtxt(fname, usecols=(0, 3, 4)).T
        alice_glauber[attr] = dict(x=x, y=y, yerr=yerr)

    # read trento attributes
    post_samples = defaultdict(list)
    for fname in glob.glob('cache/*.dat'):
        events = np.loadtxt(fname)
        sorted_events = events[events[:, 4].argsort()][::-1]

        for attr, index in plot_attrs:
            post_samples[attr].append(
                    sorted_events[:, index].reshape(nbin, -1).mean(axis=1)
            )

    # plot trento npart and ncoll
    for (attr, index), col in zip(plot_attrs, axes.T):
        ylabels = [attr, r'{}/$\langle$ {} $\rangle$'.format(attr, attr)]
        samples = np.array(post_samples[attr])

        alice_glb = alice_glauber[attr]

        trento = dict(
            x=np.linspace(0, 100, nbin),
            y=samples.mean(axis=0),
            yerr=samples.std(axis=0),
        )

        handles = []

        for ax, ylabel in zip(col, ylabels):

            for model, color in [(trento, blue), (alice_glb, red)]:

                x, y, dy = [model[k] for k in ('x', 'y', 'yerr')] 

                if ax.is_first_row():
                    line, = ax.plot(x, y, color=color, zorder=1)
                    band = ax.fill_between(x, y - dy, y + dy,
                            color=color, alpha=.2, lw=0, zorder=0, label='95% CI')
                    handles.append((line, band))

                else:
                    y0 = np.interp(x, trento['x'], trento['y'])
                    ax.plot(x, y/y0, color=color, zorder=1)
                    ax.fill_between(x, (y - dy)/y0, (y + dy)/y0,
                        color=color, alpha=.2, lw=0, zorder=0, label='95% CI')

                    ax.set_xlabel('Centrality')

            ax.set_ylabel(ylabel)

    ax_top_right = axes[0][1]
    ax_top_right.legend(handles, ['Trento', 'ALICE GLb.'])
    set_tight(pad=.5)


def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser()
    parser.add_argument('plots', nargs='*')
    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            if i in plot_functions:
                plot_functions[i]()
            else:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f()

if __name__ == "__main__":
    main()
